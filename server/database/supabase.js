import { createClient } from '@supabase/supabase-js';
import { Pool } from 'pg';

/**
 * Supabase PostgreSQL Integration for lcodegen
 * –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Supabase PostgreSQL –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
 */

class SupabaseDatabase {
  constructor() {
    this.supabase = null;
    this.pool = null;
    this.initialized = false;
  }

  /**
   * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Supabase
   */
  async initialize() {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
      if (!process.env.SUPABASE_URL || !process.env.SUPABASE_ANON_KEY) {
        throw new Error('SUPABASE_URL –∏ SUPABASE_ANON_KEY –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
      }

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Supabase –∫–ª–∏–µ–Ω—Ç–∞
      this.supabase = createClient(
        process.env.SUPABASE_URL,
        process.env.SUPABASE_ANON_KEY,
        {
          auth: {
            autoRefreshToken: true,
            persistSession: true
          },
          db: {
            schema: 'public'
          }
        }
      );

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PostgreSQL –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
      if (process.env.DATABASE_URL) {
        this.pool = new Pool({
          connectionString: process.env.DATABASE_URL,
          ssl: {
            rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED === 'true'
          },
          max: parseInt(process.env.DB_POOL_MAX) || 10,
          min: parseInt(process.env.DB_POOL_MIN) || 2,
          idleTimeoutMillis: parseInt(process.env.DB_POOL_IDLE_TIMEOUT) || 30000,
          connectionTimeoutMillis: parseInt(process.env.DB_POOL_CONNECTION_TIMEOUT) || 2000,
        });

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        await this.testConnection();
      }

      this.initialized = true;
      console.log('‚úÖ Supabase PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ');
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Supabase:', error);
      throw error;
    }
  }

  /**
   * –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
   */
  async testConnection() {
    try {
      if (this.pool) {
        const client = await this.pool.connect();
        const result = await client.query('SELECT NOW()');
        client.release();
        console.log('‚úÖ PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ:', result.rows[0]);
      }

      if (this.supabase) {
        const { data, error } = await this.supabase
          .from('_supabase_migrations')
          .select('version')
          .limit(1);
        
        if (error && error.code !== 'PGRST116') { // PGRST116 = table not found (—ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ)
          throw error;
        }
        console.log('‚úÖ Supabase –∫–ª–∏–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω —É—Å–ø–µ—à–Ω–æ');
      }
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:', error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ Supabase –∫–ª–∏–µ–Ω—Ç–∞
   */
  getSupabaseClient() {
    if (!this.initialized) {
      throw new Error('Supabase –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –í—ã–∑–æ–≤–∏—Ç–µ initialize() —Å–Ω–∞—á–∞–ª–∞.');
    }
    return this.supabase;
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ PostgreSQL –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
   */
  getPool() {
    if (!this.initialized) {
      throw new Error('Supabase –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –í—ã–∑–æ–≤–∏—Ç–µ initialize() —Å–Ω–∞—á–∞–ª–∞.');
    }
    return this.pool;
  }

  /**
   * –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SQL –∑–∞–ø—Ä–æ—Å–∞ —á–µ—Ä–µ–∑ –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
   */
  async query(text, params = []) {
    if (!this.pool) {
      throw new Error('PostgreSQL –ø—É–ª –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    }

    const start = Date.now();
    try {
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      console.log('üìä SQL –∑–∞–ø—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω:', { text, duration, rows: result.rowCount });
      return result;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ SQL –∑–∞–ø—Ä–æ—Å–∞:', { text, error: error.message });
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ –∏–∑ –ø—É–ª–∞ –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
   */
  async getClient() {
    if (!this.pool) {
      throw new Error('PostgreSQL –ø—É–ª –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    }
    return await this.pool.connect();
  }

  /**
   * –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è lcodegen —Å–µ—Å—Å–∏–π
   */
  async createCodegenTables() {
    try {
      const createSessionsTable = `
        CREATE TABLE IF NOT EXISTS codegen_sessions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          session_id VARCHAR(255) UNIQUE NOT NULL,
          project_path TEXT,
          command TEXT,
          status VARCHAR(50) DEFAULT 'active',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          metadata JSONB DEFAULT '{}'::jsonb
        );
      `;

      const createMessagesTable = `
        CREATE TABLE IF NOT EXISTS codegen_messages (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          session_id VARCHAR(255) NOT NULL,
          role VARCHAR(50) NOT NULL,
          content TEXT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          metadata JSONB DEFAULT '{}'::jsonb,
          FOREIGN KEY (session_id) REFERENCES codegen_sessions(session_id) ON DELETE CASCADE
        );
      `;

      const createIndexes = `
        CREATE INDEX IF NOT EXISTS idx_codegen_sessions_status ON codegen_sessions(status);
        CREATE INDEX IF NOT EXISTS idx_codegen_sessions_created_at ON codegen_sessions(created_at);
        CREATE INDEX IF NOT EXISTS idx_codegen_messages_session_id ON codegen_messages(session_id);
        CREATE INDEX IF NOT EXISTS idx_codegen_messages_timestamp ON codegen_messages(timestamp);
      `;

      await this.query(createSessionsTable);
      await this.query(createMessagesTable);
      await this.query(createIndexes);

      console.log('‚úÖ –¢–∞–±–ª–∏—Ü—ã lcodegen —Å–æ–∑–¥–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ');
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü lcodegen:', error);
      throw error;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏ lcodegen
   */
  async saveCodegenSession(sessionData) {
    try {
      const { sessionId, projectPath, command, status = 'active', metadata = {} } = sessionData;
      
      const query = `
        INSERT INTO codegen_sessions (session_id, project_path, command, status, metadata)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (session_id) 
        DO UPDATE SET 
          project_path = EXCLUDED.project_path,
          command = EXCLUDED.command,
          status = EXCLUDED.status,
          metadata = EXCLUDED.metadata,
          updated_at = NOW()
        RETURNING *
      `;

      const result = await this.query(query, [sessionId, projectPath, command, status, JSON.stringify(metadata)]);
      return result.rows[0];
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ lcodegen:', error);
      throw error;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è lcodegen
   */
  async saveCodegenMessage(messageData) {
    try {
      const { sessionId, role, content, metadata = {} } = messageData;
      
      const query = `
        INSERT INTO codegen_messages (session_id, role, content, metadata)
        VALUES ($1, $2, $3, $4)
        RETURNING *
      `;

      const result = await this.query(query, [sessionId, role, content, JSON.stringify(metadata)]);
      return result.rows[0];
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è lcodegen:', error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π lcodegen
   */
  async getCodegenSessions(limit = 10, offset = 0) {
    try {
      const query = `
        SELECT s.*, 
               COUNT(m.id) as message_count,
               MAX(m.timestamp) as last_message_at
        FROM codegen_sessions s
        LEFT JOIN codegen_messages m ON s.session_id = m.session_id
        GROUP BY s.id
        ORDER BY s.created_at DESC
        LIMIT $1 OFFSET $2
      `;

      const result = await this.query(query, [limit, offset]);
      return result.rows;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–π lcodegen:', error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π —Å–µ—Å—Å–∏–∏
   */
  async getCodegenMessages(sessionId, limit = 50, offset = 0) {
    try {
      const query = `
        SELECT * FROM codegen_messages
        WHERE session_id = $1
        ORDER BY timestamp ASC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.query(query, [sessionId, limit, offset]);
      return result.rows;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π lcodegen:', error);
      throw error;
    }
  }

  /**
   * –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
   */
  async close() {
    try {
      if (this.pool) {
        await this.pool.end();
        console.log('‚úÖ PostgreSQL –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∑–∞–∫—Ä—ã—Ç');
      }
      this.initialized = false;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π:', error);
    }
  }
}

// –°–æ–∑–¥–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
const supabaseDB = new SupabaseDatabase();

export default supabaseDB;
